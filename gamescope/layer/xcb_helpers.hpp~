#pragma once

#include <X11/Xlib-xcb.h>
#include <xcb/composite.h>
#include <cstdio>
#include <optional>
#include <cstdlib>

namespace xcb {

  typedef struct {
    xcb_window_t window;
    xcb_get_geometry_cookie_t geo;
    xcb_query_tree_cookie_t q_tree;
<<<<<<< HEAD
    std::tuple<xcb_get_geometry_reply_t*, xcb_query_tree_reply_t*> cached_replies;
=======
    std::tuple<xcb_get_geometry_reply_t* __restrict__, xcb_query_tree_reply_t*__restrict__> cached_replies;
>>>>>>> QueuePresent-canBypassXWayland-v2
  } cookie_cache_t;

  static thread_local constinit bool g_cache_bIsValid = false; //thread_local just incase g_cache could otherwise be accessed by one thread, while it is being deleted by another thread
  static constinit cookie_cache_t g_cache = {};
  
<<<<<<< HEAD
=======
  class Prefetcher {
    public: //Note: this class is currently only meant to be used within GamescopeWSILayer::VkDeviceOverrides::QueuePresentKHR
        explicit Prefetcher(xcb_connection_t* __restrict__ connection, const xcb_window_t window) {
            g_cache = {
                .window = window,
                .geo = xcb_get_geometry(connection, window),
                .q_tree = xcb_query_tree(connection, window)
            };
            g_cache_bIsValid = true;
        }

        ~Prefetcher() {
            g_cache_bIsValid = false;
            if ( std::get<0>(g_cache.cached_replies) != nullptr )
                free(std::get<0>(g_cache.cached_replies));
            if ( std::get<1>(g_cache.cached_replies) != nullptr )
                free(std::get<1>(g_cache.cached_replies));
            g_cache.cached_replies = {nullptr,nullptr};
        }
  };
  
>>>>>>> QueuePresent-canBypassXWayland-v2
  struct ReplyDeleter {
    template <typename T>
    void operator()(T* ptr) const {
      free(const_cast<std::remove_const_t<T>*>(ptr));
    }
  };

  template <typename T>
  using Reply = std::unique_ptr<T, ReplyDeleter>;
  
<<<<<<< HEAD

  Reply<xcb_get_geometry_reply_t> CachedReply(xcb_connection_t* connection, xcb_get_geometry_cookie_t cookie)
  {
    xcb_get_geometry_reply_t* reply_copied = reinterpret_cast<xcb_get_geometry_reply_t*>(malloc(sizeof(xcb_get_geometry_reply_t)));
    if (std::get<0>(g_cache.cached_replies) == nullptr) {
        std::get<0>(g_cache.cached_replies) = xcb_get_geometry_reply(connection, cookie, nullptr);
    }

    memcpy(reinterpret_cast<void*>(reply_copied), reinterpret_cast<void*>(std::get<0>(g_cache.cached_replies)), sizeof(xcb_get_geometry_reply_t));

    return Reply<xcb_get_geometry_reply_t>{reply_copied};
  }
  
  Reply<xcb_query_tree_reply_t> CachedReply(xcb_connection_t* connection, xcb_query_tree_cookie_t cookie)
  {
    xcb_query_tree_reply_t* reply_copied = reinterpret_cast<xcb_query_tree_reply_t*>(malloc(sizeof(xcb_query_tree_reply_t)));
=======
  static Reply<xcb_get_geometry_reply_t> getCachedReply(xcb_connection_t* __restrict__ connection, const xcb_get_geometry_cookie_t cookie) {
    xcb_get_geometry_reply_t* __restrict__ reply_copied = reinterpret_cast<xcb_get_geometry_reply_t* __restrict__>(std::malloc(sizeof(xcb_get_geometry_reply_t)));
    if (std::get<0>(g_cache.cached_replies) == nullptr) {
        std::get<0>(g_cache.cached_replies) = xcb_get_geometry_reply(connection, cookie, nullptr);
    }

    std::memcpy(reply_copied,std::get<0>(g_cache.cached_replies), sizeof(xcb_get_geometry_reply_t));
    return Reply<xcb_get_geometry_reply_t>{reply_copied};
  }
  
  static Reply<xcb_query_tree_reply_t> getCachedReply(xcb_connection_t* __restrict__ connection, const xcb_query_tree_cookie_t cookie) {
    xcb_query_tree_reply_t* __restrict__ reply_copied = reinterpret_cast<xcb_query_tree_reply_t* __restrict__>(std::malloc(sizeof(xcb_query_tree_reply_t)));
>>>>>>> QueuePresent-canBypassXWayland-v2
    if (std::get<1>(g_cache.cached_replies) == nullptr) {
        std::get<1>(g_cache.cached_replies) = xcb_query_tree_reply(connection, cookie, nullptr);
    }

<<<<<<< HEAD
    memcpy(reinterpret_cast<void*>(reply_copied), reinterpret_cast<void*>(std::get<1>(g_cache.cached_replies)), sizeof(xcb_query_tree_reply_t));

    return Reply<xcb_query_tree_reply_t>{reply_copied};;
  }

  class Prefetcher
  {
    //Note: this class is currently only meant to be used within GamescopeWSILayer::VkDeviceOverrides::QueuePresentKHR
    
    //The g_class struct has a thread local g_cache_bIsValid boolean, 
    //to prevent any issue with another thread calling another GamescopeWSILayer:: function which calls an xcb:: func 
    //that might otherwise access g_cache while g_cache is being cleared at the end of GamescopeWSILayer::VkDeviceOverrides::QueuePresentKHR()
    public:
        Prefetcher() = delete;
        explicit Prefetcher(xcb_connection_t* connection, xcb_window_t window) {
            g_cache = {
                .window = window,
                .geo = xcb_get_geometry(connection, window),
                .q_tree = xcb_query_tree(connection, window)
            };
            g_cache_bIsValid = true;
        }

        ~Prefetcher() {
            g_cache_bIsValid = false;
            if (std::get<0>(g_cache.cached_replies)) {
                free(std::get<0>(g_cache.cached_replies));
                std::get<0>(g_cache.cached_replies) = nullptr;
            }
            if (std::get<1>(g_cache.cached_replies)) {
                free(std::get<1>(g_cache.cached_replies));
                std::get<1>(g_cache.cached_replies) = nullptr;
            }
=======
    std::memcpy(reply_copied, std::get<1>(g_cache.cached_replies), sizeof(xcb_query_tree_reply_t));
    return Reply<xcb_query_tree_reply_t>{reply_copied};
  }
  
  template <typename cookie_retType, typename reply_retType, typename first=xcb_connection_t*, typename... ArgsTwo>
  class XcbFetch {
    using cookie_f_ptr_t = cookie_retType (*)(first, ArgsTwo...);
    using reply_f_ptr_t = reply_retType (*)(first, cookie_retType, xcb_generic_error_t**);
    
    const cookie_f_ptr_t m_cookieFunc;
    const reply_f_ptr_t m_replyFunc;
    
    public:
        consteval XcbFetch(cookie_f_ptr_t cookieFunc, reply_f_ptr_t replyFunc) : m_cookieFunc{cookieFunc}, m_replyFunc{replyFunc} {}
        
        inline Reply<std::remove_pointer_t<reply_retType>> operator()(first conn, auto... argsTwo) { //have to use auto for argsTwo, since otherwise there'd be a type deduction conflict
            return Reply<std::remove_pointer_t<reply_retType>> { m_replyFunc(conn, m_cookieFunc(conn, argsTwo...), nullptr) };
        }
  };
  
  template <>
  class XcbFetch<xcb_get_geometry_cookie_t, xcb_get_geometry_reply_t*, xcb_connection_t*, xcb_window_t> {
    using cookie_f_ptr_t = xcb_get_geometry_cookie_t (*)(xcb_connection_t*, xcb_window_t);
    using reply_f_ptr_t = xcb_get_geometry_reply_t* (*)(xcb_connection_t*, xcb_get_geometry_cookie_t, xcb_generic_error_t**);
    
    const cookie_f_ptr_t m_cookieFunc;
    const reply_f_ptr_t m_replyFunc;
    
    public:
        consteval XcbFetch(cookie_f_ptr_t cookieFunc, reply_f_ptr_t replyFunc) : m_cookieFunc{cookieFunc}, m_replyFunc{replyFunc} {}
        
        inline Reply<xcb_get_geometry_reply_t> operator()(xcb_connection_t* conn, xcb_window_t window) {
            const bool tryCached = (g_cache_bIsValid && g_cache.window == window);
            if (tryCached) [[likely]]
                return getCachedReply(conn, g_cache.geo);

            return Reply<xcb_get_geometry_reply_t> { m_replyFunc(conn, m_cookieFunc(conn, window), nullptr) };
        }
  };
  
  template <>
  class XcbFetch<xcb_query_tree_cookie_t, xcb_query_tree_reply_t*, xcb_connection_t*, xcb_window_t> {
    using cookie_f_ptr_t = xcb_query_tree_cookie_t (*)(xcb_connection_t*, xcb_window_t);
    using reply_f_ptr_t = xcb_query_tree_reply_t* (*)(xcb_connection_t*, xcb_query_tree_cookie_t, xcb_generic_error_t**);
    
    const cookie_f_ptr_t m_cookieFunc;
    const reply_f_ptr_t m_replyFunc;
    
    public:
        consteval XcbFetch(cookie_f_ptr_t cookieFunc, reply_f_ptr_t replyFunc) : m_cookieFunc{cookieFunc}, m_replyFunc{replyFunc} {}
        
        inline Reply<xcb_query_tree_reply_t> operator()(xcb_connection_t* conn, xcb_window_t window) {
            const bool tryCached = (g_cache_bIsValid && g_cache.window == window);
            if (tryCached) [[likely]]
                return getCachedReply(conn, g_cache.q_tree);

            return Reply<xcb_query_tree_reply_t> { m_replyFunc(conn, m_cookieFunc(conn, window), nullptr) };
>>>>>>> QueuePresent-canBypassXWayland-v2
        }
  };
 
  static std::optional<xcb_atom_t> getAtom(xcb_connection_t* connection, std::string_view name) {
    auto reply = XcbFetch{xcb_intern_atom, xcb_intern_atom_reply}(connection, false, name.length(), name.data());
    if (!reply) {
      fprintf(stderr, "[Gamescope WSI] Failed to get xcb atom.\n");
      return std::nullopt;
    }
    xcb_atom_t atom = reply->atom;
    return atom;
  }

  template <typename T>
  static std::optional<T> getPropertyValue(xcb_connection_t* connection, xcb_atom_t atom) {
    static_assert(sizeof(T) % 4 == 0);

    xcb_screen_t* screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data;

    auto reply = XcbFetch{xcb_get_property, xcb_get_property_reply}(connection, false, screen->root, atom, XCB_ATOM_CARDINAL, 0, sizeof(T) / sizeof(uint32_t));
    if (!reply) {
      fprintf(stderr, "[Gamescope WSI] Failed to read T root window property.\n");
      return std::nullopt;
    }

    if (reply->type != XCB_ATOM_CARDINAL) {
      fprintf(stderr, "[Gamescope WSI] Atom of T was wrong type. Expected XCB_ATOM_CARDINAL.\n");
      return std::nullopt;
    }

    T value = *reinterpret_cast<const T *>(xcb_get_property_value(reply.get()));
    return value;
  }

  template <typename T>
  static std::optional<T> getPropertyValue(xcb_connection_t* connection, std::string_view name) {
    std::optional<xcb_atom_t> atom = getAtom(connection, name);
    if (!atom)
      return std::nullopt;

    return getPropertyValue<T>(connection, *atom);
  }

  static std::optional<xcb_window_t> getToplevelWindow(xcb_connection_t* connection, xcb_window_t window) {
    for (;;) {
<<<<<<< HEAD
      const bool tryCached = (g_cache_bIsValid && g_cache.window == window);

      xcb_query_tree_cookie_t cookie = tryCached ? g_cache.q_tree : xcb_query_tree(connection, window);

      auto reply = tryCached ? CachedReply(connection, cookie) : Reply<xcb_query_tree_reply_t>{ xcb_query_tree_reply(connection, cookie, nullptr) };
=======
      auto reply = XcbFetch{xcb_query_tree, xcb_query_tree_reply}(connection, window);
>>>>>>> QueuePresent-canBypassXWayland-v2

      if (!reply) {
        fprintf(stderr, "[Gamescope WSI] getToplevelWindow: xcb_query_tree failed for window 0x%x.\n", window);
        return std::nullopt;
      }

      if (reply->root == reply->parent)
        return window;

      window = reply->parent;
    }
  }

  static std::optional<VkRect2D> getWindowRect(xcb_connection_t* connection, xcb_window_t window) {
<<<<<<< HEAD
    const bool tryCached = (g_cache_bIsValid && g_cache.window == window);

    xcb_get_geometry_cookie_t cookie = tryCached ? g_cache.geo : xcb_get_geometry(connection, window);

    auto reply = tryCached ? CachedReply(connection, cookie) : Reply<xcb_get_geometry_reply_t>{ xcb_get_geometry_reply(connection, cookie, nullptr) };
=======
    auto reply = XcbFetch{xcb_get_geometry, xcb_get_geometry_reply}(connection, window);
>>>>>>> QueuePresent-canBypassXWayland-v2
    if (!reply) {
      fprintf(stderr, "[Gamescope WSI] getWindowRect: xcb_get_geometry failed for window 0x%x.\n", window);
      return std::nullopt;
    }

    VkRect2D rect = {
      .offset = { reply->x, reply->y },
      .extent = { reply->width, reply->height },
    };

    return rect;
  }

  static VkRect2D clip(VkRect2D parent, VkRect2D child) {
    return VkRect2D {
      .offset = child.offset,
      .extent = VkExtent2D {
        .width  = std::min<uint32_t>(child.extent.width,  std::max<int32_t>(parent.extent.width  - child.offset.x, 0)),
        .height = std::min<uint32_t>(child.extent.height, std::max<int32_t>(parent.extent.height - child.offset.y, 0)),
      },
    };
  }

  static VkExtent2D max(VkExtent2D a, VkExtent2D b) {
    return VkExtent2D {
      .width  = std::max<uint32_t>(a.width,  b.width),
      .height = std::max<uint32_t>(a.height, b.height),
    };
  }

  static std::optional<VkExtent2D> getLargestObscuringChildWindowSize(xcb_connection_t* connection, xcb_window_t window) {
    VkExtent2D largestExtent = {};

<<<<<<< HEAD
    const bool tryCached = (g_cache_bIsValid && g_cache.window == window);

    xcb_query_tree_cookie_t cookie = tryCached ? g_cache.q_tree : xcb_query_tree(connection, window);

    auto reply = tryCached ? CachedReply(connection, cookie) : Reply<xcb_query_tree_reply_t>{ xcb_query_tree_reply(connection, cookie, nullptr) };
=======
    auto reply = XcbFetch{xcb_query_tree, xcb_query_tree_reply}(connection, window);
>>>>>>> QueuePresent-canBypassXWayland-v2

    if (!reply) {
      fprintf(stderr, "[Gamescope WSI] getLargestObscuringWindowSize: xcb_query_tree failed for window 0x%x.\n", window);
      return std::nullopt;
    }

    auto ourRect = getWindowRect(connection, window);
    if (!ourRect) {
      fprintf(stderr, "[Gamescope WSI] getLargestObscuringWindowSize: getWindowRect failed for main window 0x%x.\n", window);
      return std::nullopt;
    }

    xcb_window_t* children = xcb_query_tree_children(reply.get());
    for (uint32_t i = 0; i < reply->children_len; i++) {
      xcb_window_t child = children[i];

      auto attributeReply = XcbFetch{xcb_get_window_attributes, xcb_get_window_attributes_reply}(connection, child);

      const bool obscuring =
        attributeReply &&
        attributeReply->map_state == XCB_MAP_STATE_VIEWABLE &&
        !attributeReply->override_redirect;

      if (obscuring) {
        if (auto childRect = getWindowRect(connection, child)) {
          VkRect2D clippedRect = clip(*ourRect, *childRect);
          largestExtent = max(largestExtent, clippedRect.extent);
        }
      }
    }

    return largestExtent;
  }

}

inline int32_t iabs(int32_t a) {
  if (a < 0)
    return -a;

  return a;
}
